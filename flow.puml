@startuml

actor "Account Holder" as user

box Client Domain 1 #LightBlue
  participant APP as d1
  participant "Vault API" as vapi1
  participant Comparator as comp1
  participant "Membership Svc" as memsvc1
  participant Proxy as proxy1
end box

box Client Domain 2 #LightBlue
  participant APP as d2
  participant "Vault API" as vapi2
  participant Comparator as comp2
  participant "Membership Svc" as memsvc2
  participant Proxy as proxy2
end box

box Common Hosted Services #LightRed
  participant Gateway as gate
  participant "Member Registry" as didvc
  participant "vc-rest" as vcsvc
  participant "did:orb" as dlt
  participant "Confidential Storage Hub" as edx
  participant EDV as edv
  participant WebKMS as kms
end box

group prior one-time setup
  loop for each client domain
    gate -> gate : newOrgSecret()
    gate --> d1 : (out of band) orgSecret
    d1 --> proxy1 : (out of band) configure(orgSecret)
    comp1 -> proxy1: POST /hubstore/acct
    proxy1 -> gate : POST /hubstore/acct authz=HMACSHA256(orgSecret)
    gate -> edx : POST /hubstore/acct
    edx -> gate : accountID, orgCompZCAP
    gate -> proxy1: accountID, orgCompZCAP
    proxy1 -> comp1 : accountID, orgCompZCAP
    memsvc1 -> memsvc1 : newSvcKeyPair()
    memsvc1 -> proxy1 : register(key=svcKey)
    proxy1 -> gate : register(key=svcKey, authz=HMACSHA256(orgSecret))
    gate -> didvc : POST /register Headers:Origin=www.clientdomain1.com
    didvc -> dlt : createDID(key=svcKey, serviceEndpoint=...)
    dlt -> didvc : svcDID
    didvc -> vcsvc : POST /{profileID}/credentials/composeAndIssueCredential {www.clientdomain1.com, svcDID}
    vcsvc -> didvc : didVC
    didvc -> vcsvc : POST /store {vc}}
    didvc -> gate : didVC
    gate -> proxy1 : didVC
    proxy1 -> memsvc1 : didVC
  end
end

loop for each user registration at Client Domain
  user -> d1 : Registration w/SSN
  d1 -> vapi1 : POST /vaults
  vapi1 -> vapi1 : newVaultID()
  vapi1 -> vapi1 : newVaultPrimaryKey()
  vapi1 -> kms : POST /keystores {controller=vaultPrimaryKey} authz=HMACSHA256(orgSecret)
  kms -> vapi1 : keystoreID, userKMSZCAP
  vapi1 -> edv : POST /encrypted-data-vaults {controller=vaultPrimaryKey} authz=HMACSHA256(orgSecret)
  edv -> vapi1 : edvVaultID, userEDVZCAP
  vapi1 -> d1 : vaultID
  note left: vaultserver vault created
  d1 -> vapi1 : POST /vaults/{vaultID}/docs {content={SSN}}
  vapi1 -> vapi1 : newCEK()
  vapi1 -> vapi1 : encrypt(CEK, SSN)
  vapi1 -> kms : POST /keystores/{keystoreID}/keys authz=HTTPSIG(userKMSZCAP)
  kms -> vapi1 : keyID
  vapi1 -> kms : POST /keystores/{keystoreID}/wrap {CEK, recipient=keyID} authz=HTTPSIG(userKMSZCAP)
  kms -> vapi1 : wrappedCEK
  vapi1 -> vapi1 : newEDVDocID()
  vapi1 -> vapi1 : newEDVEncryptedDoc(docID, encryptedSSN, wrappedCEK)
  vapi1 -> edv : POST /encrypted-data-vaults/{vaultID}/documents {encryptedDoc} authz=HTTPSIG(userEDVZCAP)
  edv -> vapi1 : edvDocURI
  vapi1 -> d1 : docID
  note left: SSN encrypted and stored
end

group user links their account across client domains
  user -> d1 : Click "Link 'With' Account"
  d1 -> user : NASCAR display with Client Domains
  user -> d1 : click on Client Domain 2
  d1 -> memsvc1 : getMembership()
  memsvc1 -> d1 : didVC
  d1 --> d2 : GET /oauth2/authorize?request=OIDCRequestObject{client_id, scope, redirect_uri, didVC}
  note left
    * domain of redirect_uri MUST match the domain identified in didVC
    * TODO custom request object
  end note
  note right: TODO scope?
  user -> d2 : (optional) login
  user -> d2 : consent to link accounts with SSN
  d2 -> memsvc2 : queryMembership(didVC)
  memsvc2 -> didvc : queryMembership(didVC)
  didvc -> vcsvc : GET /status/{didVC.ID}
  vcsvc -> didvc : status
  didvc -> didvc : validate status
  didvc -> memsvc2 : did:orb:svc1, www.clientdomain1.com
  memsvc2 -> d2 : did:orb:svc1, www.clientdomain1.com
  d2 -> comp2 : POST /authorizations {did:orb:svc1, vaultID, docID, exp=5min}
  comp2 -> dlt : resolve(did:orb:sv1, authz=HMACSHA256(orgSecret))
  dlt -> comp2 : did:orb:svc1
  comp2 -> vapi2 : POST /vaults/{vaultID}/authorizations {hubPubDID, scope=["read", vaultID, docID, exp=5min]}
  vapi2 -> comp2 : hubEDVZCAP, hubKMSZCAP
  comp2 -> vapi2 : GET /vaults/{vaultID}/docs/{docID}
  vapi2 -> comp2 : edvDocURI
  comp2 -> edx : POST /hubstore/acct/{accountID}/queries {edvDocURI, hubEDVZCAP, hubKMSZCAP} authz=HTTPSIG(orgCompZCAP)
  edx -> comp2 : queryID
  comp2 -> edx : POST /hubstore/acct/{accountID}/authorizations {queryID, did:orb:svc1#key, scope="reference"} authz=HTTPSIG(orgCompZCAP)
  note left
    "reference" != "read". The requesting party will be allowed to reference
    the query from another query, but won't be able to retrieve the query object
    itself.
  end note
  edx -> comp2 : orgCompQueryZCAP
  comp2 -> d2 : queryID, orgCompQueryZCAP
  d2 --> d1 : (redirect) oauth2 authorization response with code
  d1 -> d2 : oauth2 token request with code
  d2 -> d1 : access_token(queryID, orgCompQueryZCAP)
  note left: TODO access_token == orgCompQueryZCAP ?
  d1 -> comp1 : POST /compare {vaultID, docID, orgCompQueryAP}
  note left: TODO missing queryID parameter
  comp1 -> vapi1 : POST /vaults/{vaultID}/authorizations {hubPubDID, scope=["read", vaultID, docID, exp=5min]}
  vapi1 -> comp1 : hubEDVZCAP, hubKMSZCAP
  comp1 -> vapi1 : GET /vaults/{vaultID}/docs/{docID}
  vapi1 -> comp1 : edvDocURI
  comp1 -> edx : POST /disclose {edvDocURI, queryID, hubEDVZCAP, hubKMSZCAP} authz=HTTPSIG(orgCompZCAP)
  edx -> edx : array := newArray()
  loop for each query object
    alt if query object is ref
      edx -> edx : lookup Query+Auth Objects by handle
    end
    edx -> edv : readDoc(QueryObject, authz=HTTPSIG(hubEDVZCAP))
    edv -> edx : encryptedDoc
    edx -> kms : unwrap(wrappedCEK, authz=HTTPSIG(hubKMSZCAP))
    kms -> edx : unwrappedCEK
    edx -> edx : let doc = decrypt(encryptedDoc, unwrappedCEK)
    alt if query object has path
      edx -> edx : doc = select(jsonPath, decryptedDoc)
    end
    edx -> edx : append(array, doc)
  end
  edx -> edx : let result = eval(operator, array)
  note left: boolean
  edx -> comp1 : result
  comp1 -> d1 : result
end

@enduml
