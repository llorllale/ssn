@startuml

actor "Account Holder" as user

box Client Domain 1 #LightBlue
  participant APP as d1
  participant "Vault API" as vapi1
  participant Comparator as comp1
end box

box Client Domain 2 #LightBlue
  participant APP as d2
  participant "Vault API" as vapi2
  participant Comparator as comp2
end box

box Common Hosted Services #LightRed
  participant Gateway as gate
  participant "Trustbloc DID" as dlt
  participant "Confidential Storage Hub" as edx
  participant EDV as edv
  participant WebKMS as kms
end box

group prior one-time setup
  loop for each client domain
    gate -> gate : newOrgSecret()
    gate --> d1 : (out of band) orgSecret
    d1 --> comp1 : init(orgSecret)
    comp1 -> gate : POST /hubstore/acct authz=HMACSHA256(orgSecret)
    gate -> edx : POST /hubstore/acct
    edx -> gate : accountID, orgCompZCAP
    gate -> comp1 : accountID, orgCompZCAP
    d1 --> vapi1 : init(orgSecret)
    vapi1 -> vapi1 : newSvcKeyPair()
    vapi1 -> gate : createDID(key=svcKey, serviceEndpoint=..., authz=HMACSHA256(orgSecret))
    gate -> dlt : createDID(key=svcKey, serviceEndpoint=...)
    dlt -> gate : svcDID
    gate -> vapi1 : svcDID
    vapi1 -> d1 : svcDID
  end
end

loop for each user registration at Client Domain
  user -> d1 : Registration w/SSN
  d1 -> vapi1 : POST /vaults
  vapi1 -> vapi1 : newVaultID()
  vapi1 -> vapi1 : newVaultPrimaryKey()
  vapi1 -> kms : POST /keystores {controller=vaultPrimaryKey} authz=HMACSHA256(orgSecret)
  kms -> vapi1 : keystoreID, userKMSZCAP
  vapi1 -> edv : POST /encrypted-data-vaults {controller=vaultPrimaryKey} authz=HMACSHA256(orgSecret)
  edv -> vapi1 : edvVaultID, userEDVZCAP
  vapi1 -> d1 : vaultID
  note left: vaultserver vault created
  d1 -> vapi1 : POST /vaults/{vaultID}/docs {content={SSN}}
  vapi1 -> vapi1 : newCEK()
  vapi1 -> vapi1 : encrypt(CEK, SSN)
  vapi1 -> kms : POST /keystores/{keystoreID}/keys authz=HTTPSIG(userKMSZCAP)
  kms -> vapi1 : keyID
  vapi1 -> kms : POST /keystores/{keystoreID}/wrap {CEK, recipient=keyID} authz=HTTPSIG(userKMSZCAP)
  kms -> vapi1 : wrappedCEK
  vapi1 -> vapi1 : newEDVDocID()
  vapi1 -> vapi1 : newEDVEncryptedDoc(docID, encryptedSSN, wrappedCEK)
  vapi1 -> edv : POST /encrypted-data-vaults/{vaultID}/documents {encryptedDoc} authz=HTTPSIG(userEDVZCAP)
  edv -> vapi1 : edvDocURI
  vapi1 -> d1 : docID
  note left: SSN encrypted and stored
end

group user links their account across client domains
  user -> d1 : Click "Link 'With' Account"
  d1 -> user : NASCAR display with Client Domains
  user -> d1 : click on Client Domain 2
  d1 -> d2 : svc1DID#key
  note left: how is this call authenticated?
  d2 -> d2 : new short-lived code
  d2 -> d1 : code, "http://client2.com/acct/link"
  d1 -> user : link http://client2.com/acct/link?code=abc123
  user -> d1 : click on link
  user --> d2 : (redirect) login
  d2 -> comp2 : POST /authorizations {did:trustbloc:svc1, vaultID, docID, exp=5min}
  comp2 -> dlt : resolve(svc1DID, authz=HMACSHA256(orgSecret))
  dlt -> comp2 : did:trustbloc:svc1
  comp2 -> vapi2 : POST /vaults/{vaultID}/authorizations {hubPubDID, scope=["read", vaultID, docID, exp=5min]}
  vapi2 -> comp2 : hubEDVZCAP, hubKMSZCAP
  comp2 -> vapi2 : GET /vaults/{vaultID}/docs/{docID}
  vapi2 -> comp2 : edvDocURI
  comp2 -> edx : POST /hubstore/acct/{accountID}/queries {edvDocURI, hubEDVZCAP, hubKMSZCAP} authz=HTTPSIG(orgCompZCAP)
  edx -> comp2 : queryID
  comp2 -> edx : POST /hubstore/acct/{accountID}/authorizations {queryID, did:trustbloc:svc1#key, scope="reference"} authz=HTTPSIG(orgCompZCAP)
  note left
    "reference" != "read". The requesting party will be allowed to reference
    the query from another query, but won't be able to retrieve the query object
    itself.
  end note
  edx -> comp2 : orgCompQueryZCAP
  comp2 -> d2 : queryID, orgCompQueryZCAP
  d1 -> d2 : (polling) done?
  d2 -> d1 : queryID, orgCompQueryZCAP
  d1 -> comp1 : POST /compare {vaultID, docID, queryID, orgCompQueryZCAP}
  comp1 -> vapi1 : POST /vaults/{vaultID}/authorizations {hubPubDID, scope=["read", vaultID, docID, exp=5min]}
  vapi1 -> comp1 : hubEDVZCAP, hubKMSZCAP
  comp1 -> vapi1 : GET /vaults/{vaultID}/docs/{docID}
  vapi1 -> comp1 : edvDocURI
  comp1 -> edx : POST /disclose {edvDocURI, queryID, hubEDVZCAP, hubKMSZCAP} authz=HTTPSIG(orgCompZCAP)
  edx -> edx : array := newArray()
  loop for each query object
    alt if query object is ref
      edx -> edx : lookup Query+Auth Objects by handle
    end
    edx -> edv : readDoc(QueryObject, authz=HTTPSIG(hubEDVZCAP))
    edv -> edx : encryptedDoc
    edx -> kms : unwrap(wrappedCEK, authz=HTTPSIG(hubKMSZCAP))
    kms -> edx : unwrappedCEK
    edx -> edx : let doc = decrypt(encryptedDoc, unwrappedCEK)
    alt if query object has path
      edx -> edx : doc = select(jsonPath, decryptedDoc)
    end
    edx -> edx : append(array, doc)
  end
  edx -> edx : let result = eval(operator, array)
  note left: boolean
  edx -> comp1 : result
  comp1 -> d1 : result
end

@enduml
